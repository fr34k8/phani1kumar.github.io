!function(){"use strict";function constValue(e){return"null"===e.type?null:"NaN"===e.type?NaN:"Infinity"===e.type?e.negative?-(1/0):1/0:e.value}function minOverloadLength(e){return e.length?e.map(function(e){return e.arguments?e.arguments.filter(function(e){return!e.optional&&!e.variadic}).length:0}).reduce(function(e,t){return Math.min(e,t)}):0}function throwOrReject(e,t,s,r,n,a,o){if("Promise"!==t.idlType.generic)assert_throws(new TypeError,function(){s.apply(r,n)},a),o();else try{promise_rejects(e,new TypeError,s.apply(r,n)).then(o,o)}catch(t){e.step(function(){assert_unreached('Throws "'+t+'" instead of rejecting promise'),o()})}}function awaitNCallbacks(e,t,s){var r=0;return function(){r++,r>=e&&t()}}function exposed_in(e){if("document"in self)return e.indexOf("Window")>=0;if("DedicatedWorkerGlobalScope"in self&&self instanceof DedicatedWorkerGlobalScope)return e.indexOf("Worker")>=0||e.indexOf("DedicatedWorker")>=0;if("SharedWorkerGlobalScope"in self&&self instanceof SharedWorkerGlobalScope)return e.indexOf("Worker")>=0||e.indexOf("SharedWorker")>=0;if("ServiceWorkerGlobalScope"in self&&self instanceof ServiceWorkerGlobalScope)return e.indexOf("Worker")>=0||e.indexOf("ServiceWorker")>=0;throw"Unexpected global object"}function IdlObject(){}function IdlDictionary(e){this.name=e.name,this.members=e.members,this.base=e.inheritance}function IdlInterface(e,t){this.name=e.name,this.array=e.array,this.untested=e.untested,this.extAttrs=e.extAttrs,this.members=e.members.map(function(e){return new IdlInterfaceMember(e)}),this.has_extended_attribute("Unforgeable")&&this.members.filter(function(e){return!e.static&&("attribute"==e.type||"operation"==e.type)}).forEach(function(e){return e.isUnforgeable=!0}),this.base=e.inheritance,this._is_callback=t}function IdlInterfaceMember(e){for(var t in e)this[t]=e[t];"extAttrs"in this||(this.extAttrs=[]),this.isUnforgeable=this.has_extended_attribute("Unforgeable")}function create_suitable_object(e){if(e.nullable)return null;switch(e.idlType){case"any":case"boolean":return!0;case"byte":case"octet":case"short":case"unsigned short":case"long":case"unsigned long":case"long long":case"unsigned long long":case"float":case"double":case"unrestricted float":case"unrestricted double":return 7;case"DOMString":case"ByteString":case"USVString":return"foo";case"object":return{a:"b"};case"Node":return document.createTextNode("abc")}return null}function IdlEnum(e){this.name=e.name,this.values=e.values}function IdlTypedef(e){this.name=e.name,this.values=e.values}var fround=function(){if(Math.fround)return Math.fround;var e=new Float32Array(1);return function(t){return e[0]=t,e[0]}}();self.IdlArray=function(){this.members={},this.objects={},this.partials=[],this.implements={}},IdlArray.prototype.add_idls=function(e){this.internal_add_idls(WebIDL2.parse(e))},IdlArray.prototype.add_untested_idls=function(e){for(var t=WebIDL2.parse(e),s=0;s<t.length;s++)if(t[s].untested=!0,"members"in t[s])for(var r=0;r<t[s].members.length;r++)t[s].members[r].untested=!0;this.internal_add_idls(t)},IdlArray.prototype.internal_add_idls=function(e){e.forEach(function(e){if("interface"==e.type&&e.partial)return void this.partials.push(e);if("implements"==e.type)return e.target in this.implements||(this.implements[e.target]=[]),void this.implements[e.target].push(e.implements);if(e.array=this,e.name in this.members)throw"Duplicate identifier "+e.name;switch(e.type){case"interface":this.members[e.name]=new IdlInterface(e,!1);break;case"dictionary":this.members[e.name]=new IdlDictionary(e);break;case"typedef":this.members[e.name]=new IdlTypedef(e);break;case"callback":console.log("callback not yet supported");break;case"enum":this.members[e.name]=new IdlEnum(e);break;case"callback interface":this.members[e.name]=new IdlInterface(e,!0);break;default:throw e.name+": "+e.type+" not yet supported"}}.bind(this))},IdlArray.prototype.add_objects=function(e){for(var t in e)t in this.objects?this.objects[t]=this.objects[t].concat(e[t]):this.objects[t]=e[t]},IdlArray.prototype.prevent_multiple_testing=function(e){this.members[e].prevent_multiple_testing=!0},IdlArray.prototype.recursively_get_implements=function(e){var t=this.implements[e];if(void 0===t)return[];for(var s=0;s<this.implements[e].length;s++)if(t=t.concat(this.recursively_get_implements(t[s])),t.indexOf(t[s])!=t.lastIndexOf(t[s]))throw"Circular implements statements involving "+t[s];return t},IdlArray.prototype.test=function(){this.partials.forEach(function(e){if(!(e.name in this.members&&this.members[e.name]instanceof IdlInterface))throw"Partial interface "+e.name+" with no original interface";e.extAttrs&&e.extAttrs.forEach(function(t){this.members[e.name].extAttrs.push(t)}.bind(this)),e.members.forEach(function(t){this.members[e.name].members.push(new IdlInterfaceMember(t))}.bind(this))}.bind(this)),this.partials=[];for(var e in this.implements)this.recursively_get_implements(e).forEach(function(t){var s=e+" implements "+t+", but ";if(!(e in this.members))throw s+e+" is undefined.";if(!(this.members[e]instanceof IdlInterface))throw s+e+" is not an interface.";if(!(t in this.members))throw s+t+" is undefined.";if(!(this.members[t]instanceof IdlInterface))throw s+t+" is not an interface.";this.members[t].members.forEach(function(t){this.members[e].members.push(new IdlInterfaceMember(t))}.bind(this))}.bind(this));this.implements={},Object.getOwnPropertyNames(this.members).forEach(function(e){var t=this.members[e];if(t instanceof IdlInterface){var s=t.extAttrs.filter(function(e){return"Exposed"==e.name});if(s.length>1)throw"Unexpected Exposed extended attributes on "+e+": "+s;var r=1===s.length?s[0].rhs.value:["Window"];t.exposed=exposed_in(r)}}.bind(this));for(var t in this.members)this.members[t].test(),t in this.objects&&this.objects[t].forEach(function(e){this.members[t].test_object(e)}.bind(this))},IdlArray.prototype.assert_type_is=function(e,t){if("any"!=t.idlType&&!(t.nullable&&null===e||t.array)){if(t.sequence){if(assert_true(Array.isArray(e),"is not array"),!e.length)return;return void this.assert_type_is(e[0],t.idlType.idlType)}switch(t=t.idlType){case"void":return void assert_equals(e,void 0);case"boolean":return void assert_equals(typeof e,"boolean");case"byte":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(-128<=e&&e<=127,"byte "+e+" not in range [-128, 127]");case"octet":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(0<=e&&e<=255,"octet "+e+" not in range [0, 255]");case"short":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(-32768<=e&&e<=32767,"short "+e+" not in range [-32768, 32767]");case"unsigned short":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(0<=e&&e<=65535,"unsigned short "+e+" not in range [0, 65535]");case"long":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(-2147483648<=e&&e<=2147483647,"long "+e+" not in range [-2147483648, 2147483647]");case"unsigned long":return assert_equals(typeof e,"number"),assert_equals(e,Math.floor(e),"not an integer"),void assert_true(0<=e&&e<=4294967295,"unsigned long "+e+" not in range [0, 4294967295]");case"long long":return void assert_equals(typeof e,"number");case"unsigned long long":case"DOMTimeStamp":return assert_equals(typeof e,"number"),void assert_true(0<=e,"unsigned long long is negative");case"float":return assert_equals(typeof e,"number"),assert_equals(e,fround(e),"float rounded to 32-bit float should be itself"),assert_not_equals(e,1/0),assert_not_equals(e,-(1/0)),void assert_not_equals(e,NaN);case"DOMHighResTimeStamp":case"double":return assert_equals(typeof e,"number"),assert_not_equals(e,1/0),assert_not_equals(e,-(1/0)),void assert_not_equals(e,NaN);case"unrestricted float":return assert_equals(typeof e,"number"),void assert_equals(e,fround(e),"unrestricted float rounded to 32-bit float should be itself");case"unrestricted double":return void assert_equals(typeof e,"number");case"DOMString":return void assert_equals(typeof e,"string");case"ByteString":return assert_equals(typeof e,"string"),void assert_regexp_match(e,/^[\x00-\x7F]*$/);case"USVString":return assert_equals(typeof e,"string"),void assert_regexp_match(e,/^([\x00-\ud7ff\ue000-\uffff]|[\ud800-\udbff][\udc00-\udfff])*$/);case"object":return void assert_true("object"==typeof e||"function"==typeof e,"wrong type: not object or function")}if(!(t in this.members))throw"Unrecognized type "+t;if(this.members[t]instanceof IdlInterface)assert_true("object"==typeof e||"function"==typeof e,"wrong type: not object or function"),e instanceof Object&&!this.members[t].has_extended_attribute("NoInterfaceObject")&&t in self&&assert_true(e instanceof self[t],"not instanceof "+t);else if(this.members[t]instanceof IdlEnum)assert_equals(typeof e,"string");else if(this.members[t]instanceof IdlDictionary);else if(!(this.members[t]instanceof IdlTypedef))throw"Type "+t+" isn't an interface or dictionary"}},IdlObject.prototype.test=function(){},IdlObject.prototype.has_extended_attribute=function(e){return this.extAttrs.some(function(t){return t.name==e})},IdlDictionary.prototype=Object.create(IdlObject.prototype),IdlInterface.prototype=Object.create(IdlObject.prototype),IdlInterface.prototype.is_callback=function(){return this._is_callback},IdlInterface.prototype.has_constants=function(){return this.members.some(function(e){return"const"===e.type})},IdlInterface.prototype.is_global=function(){return this.extAttrs.some(function(e){return"Global"===e.name||"PrimaryGlobal"===e.name})},IdlInterface.prototype.test=function(){if(!this.has_extended_attribute("NoInterfaceObject")){if(!this.exposed)return void test(function(){assert_false(this.name in self)}.bind(this),this.name+" interface: existence and properties of interface object");this.untested||this.test_self(),this.test_members()}},IdlInterface.prototype.test_self=function(){test(function(){if(!this.is_callback()||this.has_constants()){assert_own_property(self,this.name,"self does not have own property "+format_value(this.name));var e=Object.getOwnPropertyDescriptor(self,this.name);if(assert_false("get"in e,"self's property "+format_value(this.name)+" has getter"),assert_false("set"in e,"self's property "+format_value(this.name)+" has setter"),assert_true(e.writable,"self's property "+format_value(this.name)+" is not writable"),assert_false(e.enumerable,"self's property "+format_value(this.name)+" is enumerable"),assert_true(e.configurable,"self's property "+format_value(this.name)+" is not configurable"),this.is_callback())return void assert_equals(Object.getPrototypeOf(self[this.name]),Object.prototype,"prototype of self's property "+format_value(this.name)+" is not Object.prototype");assert_class_string(self[this.name],"Function","class string of "+this.name);var t=Object.getPrototypeOf(self[this.name]);if(this.base){var s=!this.array.members[this.base].has_extended_attribute("NoInterfaceObject");s&&(assert_own_property(self,this.base,"should inherit from "+this.base+", but self has no such property"),assert_equals(t,self[this.base],"prototype of "+this.name+" is not "+this.base))}else assert_equals(t,Function.prototype,"prototype of self's property "+format_value(this.name)+" is not Function.prototype");this.has_extended_attribute("Constructor")||(assert_throws(new TypeError,function(){self[this.name]()}.bind(this),"interface object didn't throw TypeError when called as a function"),assert_throws(new TypeError,function(){new self[this.name]}.bind(this),"interface object didn't throw TypeError when called as a constructor"))}}.bind(this),this.name+" interface: existence and properties of interface object"),this.is_callback()||test(function(){assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),assert_own_property(self[this.name],"length");var e=Object.getOwnPropertyDescriptor(self[this.name],"length");assert_false("get"in e,this.name+".length has getter"),assert_false("set"in e,this.name+".length has setter"),assert_false(e.writable,this.name+".length is writable"),assert_false(e.enumerable,this.name+".length is enumerable"),assert_true(e.configurable,this.name+".length is not configurable");var t=this.extAttrs.filter(function(e){return"Constructor"==e.name}),s=minOverloadLength(t);assert_equals(self[this.name].length,s,"wrong value for "+this.name+".length")}.bind(this),this.name+" interface object length"),this.is_callback()&&!this.has_constants()||test(function(){assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),assert_own_property(self[this.name],"name");var e=Object.getOwnPropertyDescriptor(self[this.name],"name");assert_false("get"in e,this.name+".name has getter"),assert_false("set"in e,this.name+".name has setter"),assert_false(e.writable,this.name+".name is writable"),assert_false(e.enumerable,this.name+".name is enumerable"),assert_true(e.configurable,this.name+".name is not configurable"),assert_equals(self[this.name].name,this.name,"wrong value for "+this.name+".name")}.bind(this),this.name+" interface object name"),test(function(){if(!this.is_callback()||this.has_constants()){if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),this.is_callback())return void assert_false("prototype"in self[this.name],this.name+' should not have a "prototype" property');assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"');var e=Object.getOwnPropertyDescriptor(self[this.name],"prototype");if(assert_false("get"in e,this.name+".prototype has getter"),assert_false("set"in e,this.name+".prototype has setter"),assert_false(e.writable,this.name+".prototype is writable"),assert_false(e.enumerable,this.name+".prototype is enumerable"),assert_false(e.configurable,this.name+".prototype is configurable"),"Window"===this.name)assert_class_string(Object.getPrototypeOf(self[this.name].prototype),"WindowProperties",'Class name for prototype of Window.prototype is not "WindowProperties"');else{var t,s;this.base?(t=this.base,s=!this.array.members[t].has_extended_attribute("NoInterfaceObject")):this.has_extended_attribute("ArrayClass")?(t="Array",s=!0):(t="Object",s=!0),s?(assert_own_property(self,t,"should inherit from "+t+", but self has no such property"),assert_own_property(self[t],"prototype","should inherit from "+t+', but that object has no "prototype" property'),assert_equals(Object.getPrototypeOf(self[this.name].prototype),self[t].prototype,"prototype of "+this.name+".prototype is not "+t+".prototype")):assert_class_string(Object.getPrototypeOf(self[this.name].prototype),t+"Prototype","Class name for prototype of "+this.name+'.prototype is not "'+t+'Prototype"')}assert_class_string(self[this.name].prototype,this.name+"Prototype","class string of "+this.name+".prototype"),this.has_stringifier()||assert_equals(String(self[this.name].prototype),"[object "+this.name+"Prototype]","String("+this.name+".prototype)")}}.bind(this),this.name+" interface: existence and properties of interface prototype object"),test(function(){if(!this.is_callback()||this.has_constants()){if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),this.is_callback())return void assert_false("prototype"in self[this.name],this.name+' should not have a "prototype" property');assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"'),assert_own_property(self[this.name].prototype,"constructor",this.name+'.prototype does not have own property "constructor"');var e=Object.getOwnPropertyDescriptor(self[this.name].prototype,"constructor");assert_false("get"in e,this.name+".prototype.constructor has getter"),assert_false("set"in e,this.name+".prototype.constructor has setter"),assert_true(e.writable,this.name+".prototype.constructor is not writable"),assert_false(e.enumerable,this.name+".prototype.constructor is enumerable"),assert_true(e.configurable,this.name+".prototype.constructor in not configurable"),assert_equals(self[this.name].prototype.constructor,self[this.name],this.name+".prototype.constructor is not the same object as "+this.name)}}.bind(this),this.name+' interface: existence and properties of interface prototype object\'s "constructor" property')},IdlInterface.prototype.test_member_const=function(e){if(!this.has_constants())throw"Internal error: test_member_const called without any constants";test(function(){assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),assert_own_property(self[this.name],e.name),assert_equals(self[this.name][e.name],constValue(e.value),"property has wrong value");var t=Object.getOwnPropertyDescriptor(self[this.name],e.name);assert_false("get"in t,"property has getter"),assert_false("set"in t,"property has setter"),assert_false(t.writable,"property is writable"),assert_true(t.enumerable,"property is not enumerable"),assert_false(t.configurable,"property is configurable")}.bind(this),this.name+" interface: constant "+e.name+" on interface object"),test(function(){if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),this.is_callback())return void assert_false("prototype"in self[this.name],this.name+' should not have a "prototype" property');assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"'),assert_own_property(self[this.name].prototype,e.name),assert_equals(self[this.name].prototype[e.name],constValue(e.value),"property has wrong value");var t=Object.getOwnPropertyDescriptor(self[this.name],e.name);assert_false("get"in t,"property has getter"),assert_false("set"in t,"property has setter"),assert_false(t.writable,"property is writable"),assert_true(t.enumerable,"property is not enumerable"),assert_false(t.configurable,"property is configurable")}.bind(this),this.name+" interface: constant "+e.name+" on interface prototype object")},IdlInterface.prototype.test_member_attribute=function(e){test(function(){if(!this.is_callback()||this.has_constants())if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"'),e.static)assert_own_property(self[this.name],e.name,"The interface object must have a property "+format_value(e.name));else if(this.is_global()){assert_own_property(self,e.name,"The global object must have a property "+format_value(e.name)),assert_false(e.name in self[this.name].prototype,"The prototype object must not have a property "+format_value(e.name));var t=Object.getOwnPropertyDescriptor(self,e.name).get;assert_equals(typeof t,"function",format_value(e.name)+" must have a getter");var s,r;try{r=self[e.name],s=!0}catch(e){s=!1}s&&assert_equals(r,t.call(void 0),"Gets on a global should not require an explicit this"),this.do_interface_attribute_asserts(self,e)}else assert_true(e.name in self[this.name].prototype,"The prototype object must have a property "+format_value(e.name)),e.has_extended_attribute("LenientThis")?assert_equals(self[this.name].prototype[e.name],void 0,"getting property on prototype object must return undefined"):assert_throws(new TypeError,function(){self[this.name].prototype[e.name]}.bind(this),"getting property on prototype object must throw TypeError"),this.do_interface_attribute_asserts(self[this.name].prototype,e)}.bind(this),this.name+" interface: attribute "+e.name)},IdlInterface.prototype.test_member_operation=function(e){var t=async_test(this.name+" interface: operation "+e.name+"("+e.arguments.map(function(e){return e.idlType.idlType})+")");t.step(function(){if(this.is_callback()&&!this.has_constants())return void t.done();if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),this.is_callback())return assert_false("prototype"in self[this.name],this.name+' should not have a "prototype" property'),void t.done();assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"');var s;e.static?(assert_own_property(self[this.name],e.name,"interface object missing static operation"),s=self[this.name]):this.is_global()?(assert_own_property(self,e.name,"global object missing non-static operation"),s=self):(assert_own_property(self[this.name].prototype,e.name,"interface prototype object missing non-static operation"),s=self[this.name].prototype),this.do_member_operation_asserts(s,e,t)}.bind(this))},IdlInterface.prototype.do_member_operation_asserts=function(e,t,s){var r=s.done.bind(s),n=t.isUnforgeable,a=Object.getOwnPropertyDescriptor(e,t.name);assert_false("get"in a,"property has getter"),assert_false("set"in a,"property has setter"),assert_equals(a.writable,!n,"property should be writable if and only if not unforgeable"),assert_true(a.enumerable,"property is not enumerable"),assert_equals(a.configurable,!n,"property should be configurable if and only if not unforgeable"),assert_equals(typeof e[t.name],"function","property must be a function"),assert_equals(e[t.name].length,minOverloadLength(this.members.filter(function(e){return"operation"==e.type&&e.name==t.name})),"property has wrong .length");var o=t.arguments.map(function(e){return create_suitable_object(e.idlType)});if(t.static)r();else{var i;this.is_global()||e[t.name]==self[t.name]?i=awaitNCallbacks(1,r):(i=awaitNCallbacks(2,r),throwOrReject(s,t,e[t.name],null,o,"calling operation with this = null didn't throw TypeError",i)),throwOrReject(s,t,e[t.name],{},o,"calling operation with this = {} didn't throw TypeError",i)}},IdlInterface.prototype.test_member_stringifier=function(e){test(function(){if(!this.is_callback()||this.has_constants()){if(assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),this.is_callback())return void assert_false("prototype"in self[this.name],this.name+' should not have a "prototype" property');assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"');var t=self[this.name].prototype;assert_own_property(self[this.name].prototype,"toString","interface prototype object missing non-static operation");var s=e.isUnforgeable,r=Object.getOwnPropertyDescriptor(t,"toString");assert_false("get"in r,"property has getter"),assert_false("set"in r,"property has setter"),assert_equals(r.writable,!s,"property should be writable if and only if not unforgeable"),assert_true(r.enumerable,"property is not enumerable"),assert_equals(r.configurable,!s,"property should be configurable if and only if not unforgeable"),assert_equals(typeof t.toString,"function","property must be a function"),assert_equals(t.toString.length,0,"property has wrong .length"),assert_throws(new TypeError,function(){self[this.name].prototype.toString.apply(null,[])},"calling stringifier with this = null didn't throw TypeError"),assert_throws(new TypeError,function(){self[this.name].prototype.toString.apply({},[])},"calling stringifier with this = {} didn't throw TypeError")}}.bind(this),this.name+" interface: stringifier")},IdlInterface.prototype.test_members=function(){for(var e=0;e<this.members.length;e++){var t=this.members[e];if(!t.untested)switch(t.type){case"const":this.test_member_const(t);break;case"attribute":t.isUnforgeable||this.test_member_attribute(t);break;case"operation":t.name?t.isUnforgeable||this.test_member_operation(t):t.stringifier&&this.test_member_stringifier(t)}}},IdlInterface.prototype.test_object=function(desc){var obj,exception=null;try{obj=eval(desc)}catch(e){exception=e}var expected_typeof=this.members.some(function(e){return e.legacycaller})?"function":"object";this.test_primary_interface_of(desc,obj,exception,expected_typeof);for(var current_interface=this;current_interface;){if(!(current_interface.name in this.array.members))throw"Interface "+current_interface.name+" not found (inherited by "+this.name+")";if(current_interface.prevent_multiple_testing&&current_interface.already_tested)return;current_interface.test_interface_of(desc,obj,exception,expected_typeof),current_interface=this.array.members[current_interface.base]}},IdlInterface.prototype.test_primary_interface_of=function(e,t,s,r){!this.has_extended_attribute("NoInterfaceObject")&&(typeof t!=r||t instanceof Object)&&test(function(){assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),assert_own_property(self,this.name,"self does not have own property "+format_value(this.name)),assert_own_property(self[this.name],"prototype",'interface "'+this.name+'" does not have own property "prototype"'),assert_equals(Object.getPrototypeOf(t),self[this.name].prototype,e+"'s prototype is not "+this.name+".prototype")}.bind(this),this.name+" must be primary interface of "+e),test(function(){assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),assert_class_string(t,this.name,"class string of "+e),this.has_stringifier()||assert_equals(String(t),"[object "+this.name+"]","String("+e+")")}.bind(this),"Stringification of "+e)},IdlInterface.prototype.test_interface_of=function(e,t,s,r){this.already_tested=!0;for(var n=0;n<this.members.length;n++){var a=this.members[n];if("attribute"==a.type&&a.isUnforgeable)test(function(){assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),this.do_interface_attribute_asserts(t,a)}.bind(this),this.name+" interface: "+e+' must have own property "'+a.name+'"');else if("operation"==a.type&&a.name&&a.isUnforgeable){var o=async_test(this.name+" interface: "+e+' must have own property "'+a.name+'"');o.step(function(){assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),assert_own_property(t,a.name,"Doesn't have the unforgeable operation property"),this.do_member_operation_asserts(t,a,o)}.bind(this))}else"const"!=a.type&&"attribute"!=a.type&&"operation"!=a.type||!a.name||test(function(){if(assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),!a.static){if(this.is_global()?assert_own_property(t,a.name):assert_inherits(t,a.name),"const"==a.type&&assert_equals(t[a.name],constValue(a.value)),"attribute"==a.type){var e,n=!1;try{e=t[a.name]}catch(e){n=!0}n||this.array.assert_type_is(e,a.idlType)}"operation"==a.type&&assert_equals(typeof t[a.name],"function")}}.bind(this),this.name+" interface: "+e+' must inherit property "'+a.name+'" with the proper type ('+n+")");if("operation"==a.type&&a.name&&a.arguments.length){var o=async_test(this.name+" interface: calling "+a.name+"("+a.arguments.map(function(e){return e.idlType.idlType})+") on "+e+" with too few arguments must throw TypeError");o.step(function(){assert_equals(s,null,"Unexpected exception when evaluating object"),assert_equals(typeof t,r,"wrong typeof object"),a.static?assert_false(a.name in t):this.is_global()||a.isUnforgeable?assert_own_property(t,a.name):assert_inherits(t,a.name);for(var e=minOverloadLength(this.members.filter(function(e){return"operation"==e.type&&e.name==a.name})),n=[],i=awaitNCallbacks(e,o.done.bind(o)),l=0;l<e;l++)throwOrReject(o,a,t[a.name],t,n,"Called with "+l+" arguments",i),n.push(create_suitable_object(a.arguments[l].idlType));0===e&&i()}.bind(this))}}},IdlInterface.prototype.has_stringifier=function(){return!!this.members.some(function(e){return e.stringifier})||!(!this.base||!this.array.members[this.base].has_stringifier())},IdlInterface.prototype.do_interface_attribute_asserts=function(e,t){assert_own_property(e,t.name);var s=Object.getOwnPropertyDescriptor(e,t.name);assert_false("value"in s,"property descriptor has value but is supposed to be accessor"),assert_false("writable"in s,'property descriptor has "writable" field but is supposed to be accessor'),assert_true(s.enumerable,"property is not enumerable"),t.isUnforgeable?assert_false(s.configurable,"[Unforgeable] property must not be configurable"):assert_true(s.configurable,"property must be configurable"),assert_equals(typeof s.get,"function","getter must be Function"),t.static||(t.has_extended_attribute("LenientThis")?assert_equals(s.get.call({}),void 0,"calling getter on wrong object type must return undefined"):assert_throws(new TypeError,function(){s.get.call({})}.bind(this),"calling getter on wrong object type must throw TypeError")),assert_equals(s.get.length,0,"getter length must be 0"),!t.readonly||t.has_extended_attribute("PutForwards")||t.has_extended_attribute("Replaceable")?(assert_equals(typeof s.set,"function","setter must be function for PutForwards, Replaceable, or non-readonly attributes"),t.static||(t.has_extended_attribute("LenientThis")?assert_equals(s.set.call({}),void 0,"calling setter on wrong object type must return undefined"):assert_throws(new TypeError,function(){s.set.call({})}.bind(this),"calling setter on wrong object type must throw TypeError")),assert_equals(s.set.length,1,"setter length must be 1")):assert_equals(s.set,void 0,"setter must be undefined for readonly attributes")},IdlInterfaceMember.prototype=Object.create(IdlObject.prototype),IdlEnum.prototype=Object.create(IdlObject.prototype),IdlTypedef.prototype=Object.create(IdlObject.prototype)}();