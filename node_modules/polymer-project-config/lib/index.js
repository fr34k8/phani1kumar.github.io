/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
"use strict";
const fs = require('fs');
const path = require('path');
const logging = require('plylog');
const logger = logging.getLogger('polymer-project-config');
/**
 * The default globs for matching all user application source files.
 */
exports.defaultSourceGlobs = ['src/**/*'];
/**
 * Resolve any glob to the given path, even if glob
 * is negative (begins with '!').
 */
function resolveGlob(fromPath, glob) {
    if (glob.startsWith('!')) {
        const includeGlob = glob.substring(1);
        return '!' + path.resolve(fromPath, includeGlob);
    }
    else {
        return path.resolve(fromPath, glob);
    }
}
function getPositiveGlob(glob) {
    if (glob.startsWith('!')) {
        return glob.substring(1);
    }
    else {
        return glob;
    }
}
/**
 * Given a user-provided options object, check for deprecated options. When one
 * is found, warn the user and fix if possible.
 */
function fixDeprecatedOptions(options) {
    if (typeof options.sourceGlobs !== 'undefined') {
        logger.warn('"sourceGlobs" config option has been renamed to "sources" and will no longer be supported in future versions');
        options.sources = options.sources || options.sourceGlobs;
    }
    if (typeof options.includeDependencies !== 'undefined') {
        logger.warn('"includeDependencies" config option has been renamed to "extraDependencies" and will no longer be supported in future versions');
        options.extraDependencies = options.extraDependencies || options.includeDependencies;
    }
    return options;
}
class ProjectConfig {
    /**
     * constructor - given a ProjectOptions object, create the correct project
     * configuration for those options. This involves setting the correct
     * defaults, validating options, warning on deprecated options, and
     * calculating some additional properties.
     */
    constructor(options) {
        options = (options) ? fixDeprecatedOptions(options) : {};
        /**
         * root
         */
        if (options.root) {
            this.root = path.resolve(options.root);
        }
        else {
            this.root = process.cwd();
        }
        /**
         * entrypoint
         */
        if (options.entrypoint) {
            this.entrypoint = path.resolve(this.root, options.entrypoint);
        }
        else {
            this.entrypoint = path.resolve(this.root, 'index.html');
        }
        /**
         * shell
         */
        if (options.shell) {
            this.shell = path.resolve(this.root, options.shell);
        }
        /**
         * fragments
         */
        if (options.fragments) {
            this.fragments = options.fragments.map((e) => path.resolve(this.root, e));
        }
        else {
            this.fragments = [];
        }
        /**
         * extraDependencies
         */
        this.extraDependencies = (options.extraDependencies || [])
            .map((glob) => resolveGlob(this.root, glob));
        /**
         * sources
         */
        this.sources = (options.sources || exports.defaultSourceGlobs)
            .map((glob) => resolveGlob(this.root, glob));
        this.sources.push(this.entrypoint);
        if (this.shell) {
            this.sources.push(this.shell);
        }
        if (this.fragments) {
            this.sources = this.sources.concat(this.fragments);
        }
        /**
         * allFragments
         */
        this.allFragments = [];
        // It's important that shell is first for document-ordering of imports
        if (this.shell) {
            this.allFragments.push(this.shell);
        }
        if (this.fragments) {
            this.allFragments = this.allFragments.concat(this.fragments);
        }
        if (this.allFragments.length === 0) {
            this.allFragments.push(this.entrypoint);
        }
    }
    /**
     * Given an absolute file path to a polymer.json-like ProjectOptions object,
     * read that file. If no file exists, null is returned. If the file exists
     * but there is a problem reading or parsing it, throw an exception.
     */
    static loadOptionsFromFile(filepath) {
        try {
            const configContent = fs.readFileSync(filepath, 'utf-8');
            return JSON.parse(configContent);
        }
        catch (error) {
            // swallow "not found" errors because they are so common / expected
            if (error.code === 'ENOENT') {
                logger.debug('no polymer config file found', { file: filepath });
                return null;
            }
            // otherwise, throw an exception
            throw error;
        }
    }
    /**
     * Given an absolute file path to a polymer.json-like ProjectOptions object,
     * return a new ProjectConfig instance created with those options.
     */
    static loadConfigFromFile(filepath) {
        let configParsed = ProjectConfig.loadOptionsFromFile(filepath);
        if (!configParsed) {
            return null;
        }
        return new ProjectConfig(configParsed);
    }
    isFragment(filepath) {
        return this.allFragments.indexOf(filepath) !== -1;
    }
    isShell(filepath) {
        return (!!this.shell && (this.shell === filepath));
    }
    /**
     * Validates that a configuration is accurate, and that all paths are
     * contained within the project root.
     */
    validate() {
        const validateErrorPrefix = `Polymer Config Error`;
        if (this.entrypoint) {
            console.assert(this.entrypoint.startsWith(this.root), `${validateErrorPrefix}: entrypoint (${this.entrypoint}) ` +
                `does not resolve within root (${this.root})`);
        }
        if (this.shell) {
            console.assert(this.shell.startsWith(this.root), `${validateErrorPrefix}: shell (${this.shell}) ` +
                `does not resolve within root (${this.root})`);
        }
        this.fragments.forEach((f) => {
            console.assert(f.startsWith(this.root), `${validateErrorPrefix}: a "fragments" path (${f}) ` +
                `does not resolve within root (${this.root})`);
        });
        this.sources.forEach((s) => {
            console.assert(getPositiveGlob(s).startsWith(this.root), `${validateErrorPrefix}: a "sources" path (${s}) ` +
                `does not resolve within root (${this.root})`);
        });
        this.extraDependencies.forEach((d) => {
            console.assert(getPositiveGlob(d).startsWith(this.root), `${validateErrorPrefix}: an "extraDependencies" path (${d}) ` +
                `does not resolve within root (${this.root})`);
        });
        return true;
    }
}
exports.ProjectConfig = ProjectConfig;
